package com.github.blarosen95.mywarpsgui.Data;

import com.github.blarosen95.mywarpsgui.Items.SkullFactory;
import com.github.blarosen95.mywarpsgui.MyWarpsGUI;
import com.github.blarosen95.mywarpsgui.Util.CreateEssentialsWarpFile;
import com.github.blarosen95.mywarpsgui.Util.MyWarpsParser;
import org.bukkit.Bukkit;
import org.bukkit.OfflinePlayer;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.*;
import java.util.ArrayList;
import java.util.UUID;

public class SQLiteDatabase {
    private static Connection con;
    private static boolean hasData = false;
    private static File dataFolder = MyWarpsGUI.getInstance().getDataFolder();
    private static String warpsDBFile = dataFolder.getAbsolutePath() + File.separator + "MyWarpsGUI.db";
    private SkullFactory skullFactory = new SkullFactory();

    private static File essentialsWarpsFolder = Bukkit.getServer().getPluginManager().getPlugin("Essentials").getDataFolder();

    private String locateEssentialsWarpFile(String fileName) {
        return essentialsWarpsFolder.getAbsolutePath() + File.separator + "warps" + File.separator + fileName;
    }

    private void getConnection() throws SQLException, ClassNotFoundException {
        Class.forName("org.sqlite.JDBC");
        con = DriverManager.getConnection(String.format("jdbc:sqlite:%s", warpsDBFile));
        initialize();
    }

    private void initialize() throws SQLException {
        if (!hasData) {
            hasData = true;

            Statement statement = con.createStatement();
            ResultSet resultSet = statement.executeQuery("SELECT NAME FROM sqlite_master WHERE type='table' AND name='warps'");

            if (!resultSet.next()) {
                System.out.println("Building the warps table by parsing the YAML file from the MyWarps plugin folder.");
                Statement statement1 = con.createStatement();

                statement1.execute("CREATE TABLE warps(" +
                        "warp_id INTEGER PRIMARY KEY AUTOINCREMENT," + "warp_name VARCHAR(32)," +
                        "warp_category VARCHAR(5)," + "creator_uuid VARCHAR(36)," +
                        "creator_name VARCHAR(20)," + "essentials_warp_file VARCHAR(35));");

                //We need to add constraints to the warp_category column, it should (currently) only accept values of: town, farm, or shop (adding in an "other" category for now)
                //Statement constraintStatement = con.createStatement();
                //constraintStatement.execute("ALTER TABLE warps ADD \"CONSTRAINT\" validCategoryConstraint CHECK (warp_category IN ('Town', 'Farm', 'Shop', 'Other') );");
                //We can ensure the usage of proper values for Category when they are chosen in the menu. (todo)

                // TODO: 10/8/2018 This is one place where I'd like to make the UUIDToName API Usage run as async code, since it's processing multiple UUID!
                try {
                    MyWarpsParser myWarpsParser = new MyWarpsParser();
                    ArrayList<Warp> warps = myWarpsParser.getWarpList();
                    for (Warp warp : warps) {
                        //TODO: 10/4/2018: ensure that warp_id is autogenerated
                        PreparedStatement preparedStatement = con.prepareStatement("INSERT INTO warps (warp_name, warp_category, creator_uuid, creator_name, essentials_warp_file) VALUES(?,?,?,?,?);");
                        preparedStatement.setString(1, warp.getName());
                        preparedStatement.setString(2, warp.getCategory());
                        preparedStatement.setString(3, warp.getCreatorUUID());
                        // TODO: 10/8/2018 Third constructor for Warp? One that allows this section of code to async it?
                        preparedStatement.setString(4, warp.getCreatorName());
                        preparedStatement.setString(5, warp.getEssentialsFile());
                        preparedStatement.execute();
                    }
                } catch (IOException | SQLException e) {
                    e.printStackTrace();
                    //TODO: 10/4/2018: should we set hasData back to false here?

                }
            }
        }
    }

    // TODO: 10/4/2018: this method can only be called if:
    // (todo) the command sender's UUID.toString().equals(oldWarp.getCreatorUUID),
    // (todo) OR the command sender has the right permissions to update categories of other's warps
    public void updateCategory(Warp oldWarp, Warp newWarp) throws SQLException, ClassNotFoundException {
        if (con == null) {
            getConnection();
        }

        boolean warpExists = false;
        PreparedStatement psQuery = con.prepareStatement("SELECT * FROM warps WHERE warp_name=? AND creator_uuid=?");
        psQuery.setString(1, oldWarp.getName());
        psQuery.setString(2, oldWarp.getCreatorUUID());
        ResultSet rs = psQuery.executeQuery();
        if (rs.next()) {
            warpExists = true;
        }

        if (warpExists) {
            PreparedStatement prep = con.prepareStatement("UPDATE warps SET warp_category=? WHERE warp_name=? AND creator_uuid=?");
            prep.setString(1, newWarp.getCategory());
            prep.setString(2, oldWarp.getName());
            prep.setString(3, oldWarp.getCreatorUUID());
            prep.execute();
        }
    }

    // TODO: 10/4/2018: this method can only be called if:
    // (todo) the command sender's UUID.toString().equals(warp.getCreatorUUID),
    // (todo) OR the command sender has the right permissions to delete other's warps
    // TODO: 10/4/2018 (Successful) calls to this command should fund $500 to the warp's creator.
    // (todo) Unsuccessful calls should inform the command sender to such.
    public boolean deleteWarp(Warp warp) throws SQLException, ClassNotFoundException, IOException {
        if (con == null) {
            getConnection();
        }

        boolean warpExists = false;
        PreparedStatement psQuery = con.prepareStatement("SELECT * FROM warps WHERE warp_name=? AND creator_uuid=?");
        psQuery.setString(1, warp.getName());
        psQuery.setString(2, warp.getCreatorUUID());
        ResultSet rs = psQuery.executeQuery();
        if (rs.next()) {
            warpExists = true;
        }

        if (warpExists) {
            String fileLocation = locateEssentialsWarpFile(warp.getEssentialsFile());
            System.out.println(fileLocation);
            // TODO: 10/8/2018 does this file deletion work properly?
            Files.deleteIfExists(Paths.get(fileLocation));
            PreparedStatement prep = con.prepareStatement("DELETE FROM warps WHERE warp_name=? AND creator_uuid=?");
            prep.setString(1, warp.getName());
            prep.setString(2, warp.getCreatorUUID());
            prep.execute();
            return true;
        }
        return false;
    }

    /**
     * Used for finding all warps in a given category
     *
     * @param cat an integer representing five (5) possible options:
     *            1: All
     *            2: Town
     *            3: Shop
     *            4: Farm
     *            5: Other
     * @return a ResultSet containing the results of the query.
     */
    public ResultSet getWarpsInCategory(int cat) throws SQLException, ClassNotFoundException {
        if (con == null) {
            getConnection();
        }
        if (cat == 1) {
            Statement queryAll = con.createStatement();
            return queryAll.executeQuery("SELECT * FROM warps;");
        }
        PreparedStatement prepQuery = con.prepareStatement("SELECT * FROM warps WHERE warp_category=?");
        switch (cat) {
            case 2:
                prepQuery.setString(1, "Town");
                return prepQuery.executeQuery();
            case 3:
                prepQuery.setString(1, "Shop");
                return prepQuery.executeQuery();
            case 4:
                prepQuery.setString(1, "Farm");
                return prepQuery.executeQuery();
            case 5:
                prepQuery.setString(1, "Other");
                return prepQuery.executeQuery();
        }
        //If one of the above cases did not return our ResultSet, then the value of cat wasn't a valid option
        return null; // TODO: 10/5/2018 calls to this method should check if null was returned, and if so, they should log an error.
    }

    /**
     * Used to both add a warp to the Database as well as to create the Essentials/Warps/ .yml file for the warp.
     *
     * @param warp   the Warp object to use.
     * @param player the Player creating the Warp.
     * @return a String containing the reason why the Warp couldn't be created, null if it was created successfully.
     * @throws SQLException           throws SQLExceptions
     * @throws ClassNotFoundException throws ClassNotFoundExceptions
     */
    public String addWarp(Warp warp, Player player) throws SQLException, ClassNotFoundException {
        if (con == null) {
            getConnection();
        }

        // TODO: 10/8/2018 We could forgo this boolean and just move the database update (and file creation) procedures into the if (!rs.next()) body.
        boolean warpExists = true;

        PreparedStatement psQuery = con.prepareStatement("SELECT * FROM warps WHERE warp_name=? AND creator_uuid=?");
        psQuery.setString(1, warp.getName());
        psQuery.setString(2, warp.getCreatorUUID());
        ResultSet rs = psQuery.executeQuery();
        if (!rs.next()) {
            warpExists = false;
        }

        if (!warpExists) {
            String fileLocation = locateEssentialsWarpFile(warp.getEssentialsFile());
            if (Files.exists(Paths.get(fileLocation))) {
                return "A warp with that file name already exists, please make a post in #support on the Discord Server. Be sure to include the name you tried to use for the warp!";
                // TODO: 10/8/2018 hopefully this is only true when the warp is in the Database already. This is just to be extra safe.
            }
            //Create the file
            CreateEssentialsWarpFile createEssentialsWarpFile = new CreateEssentialsWarpFile(warp, player);
            try {
                createEssentialsWarpFile.createFileContents();
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println(String.format("Caused by player '%s' while creating the warp's %s", player.getName(), warp.getEssentialsFile()));
                return "An internal error occurred while attempting to create your warp. Your balance has not been charged for this.";
            }

            //Add the warp to our database
            PreparedStatement preparedStatement = con.prepareStatement("INSERT INTO warps (warp_name, warp_category, creator_uuid, creator_name, essentials_warp_file) VALUES (?,?,?,?,?);");
            preparedStatement.setString(1, warp.getName());
            preparedStatement.setString(2, warp.getCategory());
            preparedStatement.setString(3, warp.getCreatorUUID());
            preparedStatement.setString(4, warp.getCreatorName());
            preparedStatement.setString(5, warp.getEssentialsFile());
            preparedStatement.execute();
            return null;
        }
        return "A warp with that name already exists. You need to pick a new name.";
    }

    /**
     * Gets all warps created by a given player
     *
     * @param player Player to search for.
     * @return A ResultSet containing the warps owned by the player provided.
     * @throws SQLException           throws SQLExceptions
     * @throws ClassNotFoundException throws ClassNotFoundExceptions
     */
    public ResultSet getWarpsByPlayer(OfflinePlayer player) throws SQLException, ClassNotFoundException {
        if (con == null) {
            getConnection();
        }

        PreparedStatement psQuery = con.prepareStatement("SELECT * FROM warps WHERE creator_uuid=?");
        psQuery.setString(1, player.getUniqueId().toString());
        return psQuery.executeQuery();
    }

    public ArrayList<ItemStack> getHeads() throws SQLException, ClassNotFoundException {
        if (con == null) {
            getConnection();
        }
        ArrayList<ItemStack> heads = new ArrayList<>();
        Statement statement = con.createStatement();
        ResultSet rs = statement.executeQuery("SELECT DISTINCT creator_uuid, creator_name FROM warps;");

        while (rs.next()) {
            heads.add(skullFactory.getHead(Bukkit.getOfflinePlayer(UUID.fromString(rs.getString(1))), rs.getString(2)));
        }

        return heads;
    }

    public Warp getWarpByName(String warpName) throws SQLException, ClassNotFoundException {
        if (con == null) {
            getConnection();
        }
        PreparedStatement psQuery = con.prepareStatement("SELECT warp_name, creator_uuid, creator_name, warp_category, essentials_warp_file FROM warps WHERE warp_name=?");
        psQuery.setString(1, warpName);
        ResultSet warpSet = psQuery.executeQuery();
        if (warpSet.next()) {
            return new Warp(warpSet.getString(1), warpSet.getString(2), warpSet.getString(3), warpSet.getString(4), warpSet.getString(5));
        } else {
            System.out.println("We have an issue in getWarpByName");
            return null;
        }
    }

    public String getUUIDByWarpName(String warpName) throws SQLException, ClassNotFoundException {
        if (con == null) {
            getConnection();
        }

        PreparedStatement psQuery = con.prepareStatement("SELECT creator_uuid FROM warps WHERE warp_name=?");
        psQuery.setString(1, warpName);
        ResultSet uuidSet = psQuery.executeQuery();
        if (uuidSet.next()) {
            return uuidSet.getString(1);
        } else {
            System.out.println("We have a problem in getUUIDByWarpName!");
            return null;
        }
    }
}
